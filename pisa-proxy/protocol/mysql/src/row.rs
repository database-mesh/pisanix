// Copyright 2022 SphereEx Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use std::{ops::Range, sync::Arc};

use bytes::Buf;

use crate::{
    column::ColumnInfo,
    err::DecodeRowError,
    util::BufExt,
    value::{self, Value},
};

pub trait Row: BufExt {
    fn decode_row_with_idx<T: Value>(&mut self, idx: usize) -> value::Result<T> {
        for _ in 0..idx {
            let (length, ..) = self.get_lenc_int();
            self.advance(length as usize)
        }

        let (row_data, _) = self.get_lenc_str_bytes();

        Value::from(row_data)
    }

    fn decode_row_with_range_idx<T: Value>(
        &mut self,
        range: Range<usize>,
    ) -> Vec<value::Result<T>> {
        for _ in 1..range.start {
            let (length, ..) = self.get_lenc_int();
            self.advance(length as usize)
        }

        let mut values = vec![];

        for _ in range {
            let (row_data, _) = self.get_lenc_str_bytes();

            values.push(Value::from(row_data))
        }

        values
    }
}

/// Implements Row for T
impl<T: AsRef<[u8]> + Buf> Row for T {}

#[derive(Debug)]
pub struct RowData<T> {
    columns: Arc<[ColumnInfo]>,
    buf: T,
    // Save consumed column idx, when call decode, buf data will removed,
    // so th data index will drift.
    consumed_idx: Vec<usize>,
}

impl<T: Row> RowData<T> {
    pub fn new(columns: Arc<[ColumnInfo]>, buf: T) -> RowData<T> {
        RowData { columns, buf, consumed_idx: vec![] }
    }

    // The method must be called in column order
    pub fn decode_with_name<V: Value>(&mut self, name: &str) -> value::Result<V> {
        let try_idx = self.columns.iter().position(|x| x.column_name == name);
        if try_idx.is_none() {
            return Err(DecodeRowError::ColumnNotFound(name.to_string()).into());
        }

        let idx = try_idx.unwrap();

        if self.consumed_idx.contains(&idx) {
            return Err(DecodeRowError::ColumnAlreadyConsumed(name.to_string()).into());
        }

        self.consumed_idx.push(idx);
        self.consumed_idx.sort_unstable();

        // Find all data less then idx in consumed_idx and save count.
        // The corrent idx should be minus lt_idx_count when `lt_idx_count > 0`.
        let lt_idx_count = self.consumed_idx.iter().filter(|x| *x < &idx).count();

        self.buf.decode_row_with_idx::<V>(idx - lt_idx_count)
    }
}

#[cfg(test)]
mod test {
    use bytes::BytesMut;

    use super::Row;
    use crate::{column::Column, row::RowData};

    fn get_test_column_data() -> Vec<u8> {
        vec![
            0x18, 0x00, 0x00, 0x02, 0x03, 0x64, 0x65, 0x66, 0x00, 0x00, 0x00, 0x02, 0x49, 0x64,
            0x00, 0x0c, 0x3f, 0x00, 0x15, 0x00, 0x00, 0x00, 0x08, 0x81, 0x00, 0x00, 0x00, 0x00,
            0x1a, 0x00, 0x00, 0x03, 0x03, 0x64, 0x65, 0x66, 0x00, 0x00, 0x00, 0x04, 0x55, 0x73,
            0x65, 0x72, 0x00, 0x0c, 0x21, 0x00, 0x60, 0x00, 0x00, 0x00, 0xfd, 0x01, 0x00, 0x1f,
            0x00, 0x00, 0x1a, 0x00, 0x00, 0x04, 0x03, 0x64, 0x65, 0x66, 0x00, 0x00, 0x00, 0x04,
            0x48, 0x6f, 0x73, 0x74, 0x00, 0x0c, 0x21, 0x00, 0xc0, 0x00, 0x00, 0x00, 0xfd, 0x01,
            0x00, 0x1f, 0x00, 0x00, 0x18, 0x00, 0x00, 0x05, 0x03, 0x64, 0x65, 0x66, 0x00, 0x00,
            0x00, 0x02, 0x64, 0x62, 0x00, 0x0c, 0x21, 0x00, 0xc0, 0x00, 0x00, 0x00, 0xfd, 0x00,
            0x00, 0x1f, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x06, 0x03, 0x64, 0x65, 0x66, 0x00, 0x00,
            0x00, 0x07, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x00, 0x0c, 0x21, 0x00, 0x30,
            0x00, 0x00, 0x00, 0xfd, 0x01, 0x00, 0x1f, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x07, 0x03,
            0x64, 0x65, 0x66, 0x00, 0x00, 0x00, 0x04, 0x54, 0x69, 0x6d, 0x65, 0x00, 0x0c, 0x3f,
            0x00, 0x07, 0x00, 0x00, 0x00, 0x03, 0x81, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00,
            0x08, 0x03, 0x64, 0x65, 0x66, 0x00, 0x00, 0x00, 0x05, 0x53, 0x74, 0x61, 0x74, 0x65,
            0x00, 0x0c, 0x21, 0x00, 0x5a, 0x00, 0x00, 0x00, 0xfd, 0x00, 0x00, 0x1f, 0x00, 0x00,
            0x1a, 0x00, 0x00, 0x09, 0x03, 0x64, 0x65, 0x66, 0x00, 0x00, 0x00, 0x04, 0x49, 0x6e,
            0x66, 0x6f, 0x00, 0x0c, 0x21, 0x00, 0x2c, 0x01, 0x00, 0x00, 0xfd, 0x00, 0x00, 0x1f,
            0x00, 0x00,
        ]
    }

    fn get_test_row_data() -> Vec<u8> {
        vec![
            0x06, 0x31, 0x38, 0x36, 0x36, 0x33, 0x30, 0x04, 0x72, 0x6f, 0x6f, 0x74, 0x10, 0x31,
            0x30, 0x2e, 0x30, 0x2e, 0x32, 0x2e, 0x31, 0x30, 0x30, 0x3a, 0x34, 0x34, 0x31, 0x37,
            0x34, 0x04, 0x74, 0x65, 0x73, 0x74, 0x05, 0x53, 0x6c, 0x65, 0x65, 0x70, 0x01, 0x33,
            0x00, 0xfb,
        ]
    }

    #[test]
    fn test_decodec_row_with_idx() {
        let data = vec![
            0x14, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x6f,
            0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x0d, 0x31, 0x39, 0x32, 0x2e, 0x31, 0x36,
            0x38, 0x2e, 0x33, 0x33, 0x2e, 0x31, 0x30, 0x04, 0x72, 0x6f, 0x6f, 0x74, 0x04, 0x33,
            0x33, 0x30, 0x38, 0x02, 0x36, 0x30, 0x0e, 0x6c, 0x6f, 0x67, 0x2d, 0x62, 0x69, 0x6e,
            0x2e, 0x30, 0x30, 0x30, 0x30, 0x31, 0x35, 0x03, 0x31, 0x35, 0x34, 0x1e, 0x63, 0x65,
            0x6e, 0x74, 0x6f, 0x73, 0x2d, 0x64, 0x65, 0x76, 0x30, 0x30, 0x31, 0x2d, 0x72, 0x65,
            0x6c, 0x61, 0x79, 0x2d, 0x62, 0x69, 0x6e, 0x2e, 0x30, 0x30, 0x30, 0x30, 0x38, 0x33,
            0x01, 0x34, 0x0e, 0x6c, 0x6f, 0x67, 0x2d, 0x62, 0x69, 0x6e, 0x2e, 0x30, 0x30, 0x30,
            0x30, 0x31, 0x35, 0x0a, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6e, 0x67,
            0x03, 0x59, 0x65, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x30, 0x00, 0x01,
            0x30, 0x03, 0x31, 0x35, 0x34, 0x04, 0x31, 0x30, 0x32, 0x34, 0x04, 0x4e, 0x6f, 0x6e,
            0x65, 0x00, 0x01, 0x30, 0x02, 0x4e, 0x6f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfb, 0x02,
            0x4e, 0x6f, 0x04, 0x31, 0x30, 0x34, 0x35, 0xac, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x20,
            0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x6f, 0x20,
            0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x27, 0x72, 0x6f, 0x6f, 0x74, 0x40, 0x31,
            0x39, 0x32, 0x2e, 0x31, 0x36, 0x38, 0x2e, 0x33, 0x33, 0x2e, 0x31, 0x30, 0x3a, 0x33,
            0x33, 0x30, 0x38, 0x27, 0x20, 0x2d, 0x20, 0x72, 0x65, 0x74, 0x72, 0x79, 0x2d, 0x74,
            0x69, 0x6d, 0x65, 0x3a, 0x20, 0x36, 0x30, 0x20, 0x20, 0x6d, 0x61, 0x78, 0x69, 0x6d,
            0x75, 0x6d, 0x2d, 0x72, 0x65, 0x74, 0x72, 0x69, 0x65, 0x73, 0x3a, 0x20, 0x31, 0x30,
            0x30, 0x30, 0x30, 0x30, 0x20, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x3a,
            0x20, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x20, 0x64, 0x65, 0x6e, 0x69, 0x65, 0x64,
            0x20, 0x66, 0x6f, 0x72, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x27, 0x72, 0x6f, 0x6f,
            0x74, 0x27, 0x40, 0x27, 0x31, 0x39, 0x32, 0x2e, 0x31, 0x36, 0x38, 0x2e, 0x33, 0x33,
            0x2e, 0x31, 0x30, 0x27, 0x20, 0x28, 0x75, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x70, 0x61,
            0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x3a, 0x20, 0x59, 0x45, 0x53, 0x29, 0x01, 0x30,
            0x00, 0x00, 0x01, 0x30, 0x00, 0x00, 0x02, 0x4e, 0x6f, 0x00, 0x00, 0x00, 0x0a, 0x6f,
            0x70, 0x74, 0x69, 0x6d, 0x69, 0x73, 0x74, 0x69, 0x63, 0x01, 0x30, 0xfb, 0x36, 0x53,
            0x6c, 0x61, 0x76, 0x65, 0x20, 0x68, 0x61, 0x73, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20,
            0x61, 0x6c, 0x6c, 0x20, 0x72, 0x65, 0x6c, 0x61, 0x79, 0x20, 0x6c, 0x6f, 0x67, 0x3b,
            0x20, 0x77, 0x61, 0x69, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x6d,
            0x6f, 0x72, 0x65, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x73, 0x01, 0x30, 0x01,
            0x30, 0x01, 0x30,
        ];

        let mut buf = BytesMut::from(&data[..]);
        let res = buf.decode_row_with_idx::<String>(34).unwrap();
        assert_eq!(res, "No");

        let mut buf: &[u8] = &data;
        let res = buf.decode_row_with_idx::<String>(34).unwrap();
        assert_eq!(res, "No");
    }

    #[test]
    fn test_decode_row() {
        let mut column_buf = &get_test_column_data()[..];
        let columns = column_buf.decode_columns();
        println!("columns {:?}", columns);
        assert_eq!(columns[0].column_name, "Id");
        assert_eq!(columns[1].column_name, "User");

        let row_buf = &get_test_row_data()[..];

        let mut row = RowData::new(columns.into_boxed_slice().into(), row_buf);

        let res = row.decode_with_name::<String>("Id");
        assert_eq!(res.unwrap(), "186630");
        let res = row.decode_with_name::<String>("User");
        assert_eq!(res.unwrap(), "root");
        let res = row.decode_with_name::<String>("Host");
        assert_eq!(res.unwrap(), "10.0.2.100:44174");
        let res = row.decode_with_name::<String>("State");
        assert_eq!(res.unwrap(), "\u{0}")
    }
}
